---
description: Stand-Update über Vercel – was funktioniert, beibehalten (vercel.json, Build, QR)
alwaysApply: true
---

# Stand überall gleich – Vercel/QR (unbedingt beibehalten)

**Verbindliche Detail-Regel (QR/Stand darf nie wieder kaputtgehen):** .cursor/rules/stand-qr-niemals-zurueck.mdc

## Was funktioniert

- Push auf **main** → Vercel baut Production. Wenn Deployment **Ready** + **Current** ist, stimmt der Stand. QR **muss** Server-Stand + Cache-Bust nutzen (buildQrUrlWithBust + useQrVersionTimestamp), **nicht** nur urlWithBuildVersion.
- **vercel.json:** Gültiges JSON, **keine** überzählige `}`. No-cache für index.html und build-info.json.
- **Build:** `npm run build` = `write-build-info.js --inject-html` + … + vite build. index.html: Placeholder `<!-- BUILD_TS_INJECT -->`; Inject-Script **nicht** entfernen. buildInfo.generated.ts: einmal BUILD_LABEL, BUILD_TIMESTAMP.
- Bei Merge/Refactors: Keine doppelten Exports, keine doppelten root-divs.

## Bei Änderungen an vercel.json oder Build/Stand

- Regel **stand-qr-niemals-zurueck.mdc** einhalten (QR = Server-Stand + Bust; Inject-Script; no-cache).
- vercel.json mit `node -e "JSON.parse(require('fs').readFileSync('vercel.json','utf8')); console.log('OK')"` prüfen.
- Lokal `npm run build` vor Push.
